# entity-services-examples

This directory contains some examples of how the Entity Services feature 
can be used for data integration.  Since Entity Services works in consort
with other MarkLogic features, the examples also demonstrate

* Data Movement.  A new part of the [Java Client API] which facilitates event-based
data flows.
* Template-Driven Extraction.  A declarative way to define locations within
documents that are indexed as either tuples or RDF triples.
* Semantics model integration.  How to use RDF-based modeling technologies to
work with Entity services models.
* SQL.
* Optic API.  A query API for SQL-like access to tuples and triples, with Java,
 XQuery and JavaScript implementations.


There are several kinds of code here in the examples directory.

* QConsole workspaces that contain XQuery scripting to demonstrate 
 the Entity Services API.
* Examples of code that has been generated, then edited are in directories under 
 `example-*/ml-modules/*`
* Java classes, with source under `src/main/java` demonstrate use of the Data
 Movement SDK for an Entity Services toolchain.

*Run all commands from this directory.  The example code will not deploy to
MarkLogic if run from the parent project's directory.*


Deploying Example Code
----------------------

Each example has database configuration and stub code under one of the `example-*` directories.  To load the code for a particular example, run

`./gradlew -PexampleDir={example-dir} mlDeploy`

Filling in the name of the example directory in which you are interested.


To clean up and remove those apps and databases, run

`./gradlew -PexampleDir={example-dir} mlUnDeploy`

To change the location of the deployment edit `gradle.properties` *and* check
`src/main/resources/application.properties` to make it match.

When you deploy, the following happens:

* Databases and forests are provisioned and configured.
* Entity Services code modules to go from `example-*/ml-modules/ext` to the
 REST extension space.  This code was created from stubs generated by Entity 
 Services.
* Transforms go from `example-*/ml-modules/transforms` to REST config.  These
 transforms wrap calls to the Entity Services modules, but were authored by
 a developer.
* Search options are installed from `example-*/ml-modules/options` to REST.
 This configuration was generated by Entity Services.
* A module to generate code is installed from
 `example-*/ml-modules/services` to REST.  This extension is just used by the
 example code to invoke the Entity Services API as a demonstration.  It was
 written by the examples developer, and isn't part of the example data
 integration per se.
* Schemas that can validate canonical instance data are installed from
 `example-*/ml-schemas` to the schemas database.  Entity Services API generates
 schemas out-of-the-box.
* Extraction templates that index canonical instance data is installed
 from `example-*/ml-schemas` to the schemas database in the proper TDE
 collection.  It is a somewhat modified version of one generated by Entity
 Services.

Running Examples
----------------

Examples are run as gradle tasks.  You'll see a list of example runners when
you invoke `./gradlew tasks`.

See the individual example directories for more information on each one.


QConsole Workspaces
-------------------

Many examples have exported QConsole workspaces.  These workspaces have example
queries to help interpret what the data integration scenario looks like.

Import the workspace `{example-name}-qc.xml` into QConsole, and step through the tabs,
each of which show something about what your simulated data hub accomplished.


Generating Code
---------------

If you have models loaded in the database, you can invoke the Entity Services
code-generation API with `./gradlew genCode`.

This task iterates through models in the database and creates the code
generation artifacts for use in applications (which were the sources for
example code).  These artifacts are placed in the `gen` directory.
