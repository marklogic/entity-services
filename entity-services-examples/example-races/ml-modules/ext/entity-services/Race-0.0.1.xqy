xquery version "1.0-ml";

(: This module was generated by MarkLogic Entity Services. 
 : The source entity type document was Race-0.0.1
 :
 : Modification History:
 :   Generated at timestamp: 2016-04-13T13:41:03.235074-07:00
 :   Modified to lookup/denormalize runner into run, and source from JSON raw,
 :   For EA-3, revised to conform to new styles, enhancements, and bugfixes.
 :   Persisted by Charles Greer
 :   Date: 2016-07-20
 :)
module namespace race = "http://grechaw.github.io/entity-types#Race-0.0.1";

import module namespace functx   = "http://www.functx.com" at "/MarkLogic/functx/functx-1.0-nodoc-2007-01.xqy";
import module namespace es = "http://marklogic.com/entity-services" 
    at "/MarkLogic/entity-services/entity-services.xqy";

(:~
 : Creates a map:map representation of an entity instance from some source
 : document.
 : @param $source-node  A document or node that contains data for populating a Race
 : @return A map:map instance that holds the data for this entity type.
 :)
declare function race:extract-instance-Race(
    $source as node()
) as map:map
{
    let $source-node := es:init-source($source, 'Race')
    let $name  :=             $source-node/name ! xs:string(.)
    let $comprisedOfRuns  :=         es:extract-array($source-node/comprisedOfRuns, race:extract-instance-Run#1)
    let $wonByRunner  :=             $source-node/wonByRunner ! race:extract-instance-Runner(.)
    let $courseLength  :=             $source-node/courseLength ! xs:decimal(.)
    let $instance := es:init-instance($source-node, 'Race')
    let $wonByRunner := string($source-node/wonByRunner)
    let $runnerDoc := cts:search( collection("raw"), cts:json-property-value-query("name", $wonByRunner))
    let $_ := xdmp:log(("WINNER", $wonByRunner,  $runnerDoc))
    return $instance
         =>   map:with('name',                   $name)
         (: The following property is a local reference.                                     :)
         =>es:optional('comprisedOfRuns',        $comprisedOfRuns)
         (: The following property is a local reference.                                     :)
         =>es:optional('wonByRunner',            race:extract-instance-Runner($runnerDoc))
         =>es:optional('courseLength',           $courseLength)
        =>map:with('$attachments', xdmp:quote($source-node))
};

declare function race:extract-instance-Run(
    $source as node()
) as map:map
{
    let $source-node := es:init-source($source, 'Run')
    let $id  :=             $source-node/id ! xs:string(.)
    let $date  :=           $source-node/date ! xs:date(.)
    let $distance  :=       $source-node/distance ! xs:decimal(.)
    let $distanceLabel  :=  $source-node/distanceLabel ! xs:string(.)
    let $duration  :=       $source-node/duration ! functx:dayTimeDuration((), (), xs:decimal(.), ())
    let $runner-name := string($source-node/runByRunner)
    let $runnerDoc := cts:search( collection("raw"), cts:json-property-value-query("name", $runner-name))
    let $runByRunner  :=    race:extract-instance-Runner($runnerDoc)
    (: end customizations :)

    let $instance := es:init-instance($source-node, 'Run')

    return
        if (empty($source-node/*)) then $instance
        else $instance
        =>   map:with('id', $id)
        =>   map:with('date', $date)
        =>   map:with('distance', $distance)
        =>es:optional('distanceLabel', $distanceLabel)
        =>   map:with('duration', $duration)
        =>   map:with('runByRunner', $runByRunner)
};
    
(: modifying this one for JSON inputs, each a separate file :)
declare function race:extract-instance-Runner(
    $source as item()?
) as map:map
{
    let $source-node := es:init-source($source, 'Runner')
    (: begin customizations here :)
    let $name := $source-node/name ! xs:string(.)
    let $age := $source-node/age ! xs:int(.)
    let $gender := $source-node/gender ! xs:string(.)
    (: end customizations :)

    let $instance := es:init-instance($source-node, 'Runner')

    return
        if (empty($source-node/*))
        then $instance
        else $instance
        =>   map:with('name', $name)
        =>   map:with('age', $age)
        =>es:optional('gender', $gender)
};


declare private function race:process-duration(
    $input-value as xs:string
) as xs:dayTimeDuration?
{
    if ($input-value = ('DNS', 'DSQ'))
    then ()
    else
        let $tokens := tokenize($input-value, ":") ! xs:decimal(.)
        return functx:dayTimeDuration((), $tokens[1], $tokens[2], $tokens[3])
};

(:~
 : Creates a map:map representation of an entity instance from some source
 : document.
 : @param $source-node  A document or node that contains data for populating a Run
 : @return A map:map instance that holds the data for this entity type.
 :)
declare function race:extract-instance-Angel-Island(
$source-node as node()
) as map:map
{
(: if this $source-node is a reference without an embedded object, then short circuit. :)
json:object()
(: This line identifies the type of this instance.  Do not change it. :)
=>map:with('$type', 'Run')
=>map:with('$attachments', xdmp:quote($source-node))
=>map:with('id',                     xs:string($source-node/Bib))
=>map:with('date',                   xs:date("2016-07-23"))
=>es:optional('distance',            if ($source-node/Time = ("DNS", "DSQ")) then () else xs:decimal("13.1"))
=>es:optional('distanceLabel',       xs:string("Half Marathon"))
=>es:optional('duration',            race:process-duration($source-node/Time))
(: The following property is a local reference.                                :)
=>map:with('runByRunner',            race:extract-instance-Angel-Island-Runner($source-node))
};

(:~
 : Creates a map:map representation of an entity instance from some source
 : document.
 : @param $source-node  A document or node that contains data for populating a Runner
 : @return A map:map instance that holds the data for this entity type.
 :)
declare function race:extract-instance-Angel-Island-Runner(
$source-node as node()
) as map:map
{
json:object()
(: This line identifies the type of this instance.  Do not change it. :)
=>map:with('$type', 'Runner')
=>   map:with('name',                   xs:string($source-node/Name))
=>   map:with('age',                    xs:decimal($source-node/Age))
=>es:optional('gender',                 xs:string($source-node/Gender))

};





(:~
 : Turns an entity instance into a canonical document structure.
 : Results in either a JSON document, or an XML document that conforms
 : to the entity-services schema.
 : Using this function as-is should be sufficient for most use
 : cases, and will play well with other generated artifacts.
 : @param $entity-instance A map:map instance returned from one of the extract-instance
 :    functions.
 : @param $format Either "json" or "xml". Determines output format of function
 : @return An XML element that encodes the instance.
 :)
declare function race:instance-to-canonical(

    $entity-instance as map:map,
    $instance-format as xs:string
) as node()
{

    if ($instance-format eq "json")
    then xdmp:to-json( race:canonicalize($entity-instance) )/node()
    else race:instance-to-canonical-xml($entity-instance)
};


(:~
 : helper function to turn map structure of an instance, which uses specialized
 : keys to encode metadata, into a document tree, which uses the node structure
 : to encode all type and property information.
 :)
declare private function race:canonicalize(
    $entity-instance as map:map
) as map:map
{
    json:object()
    =>map:with( map:get($entity-instance,'$type'),
        if ( map:contains($entity-instance, '$ref') )
        then fn:head( (map:get($entity-instance, '$ref'), json:object()) )
        else
            let $m := json:object()
            let $_ :=
                for $key in map:keys($entity-instance)
                let $instance-property := map:get($entity-instance, $key)
                where ($key castable as xs:NCName)
                return
                    typeswitch ($instance-property)
                    (: This branch handles embedded objects.  You can choose to prune
                           an entity's representation of extend it with lookups here. :)
                        case json:object
                            return
                                if (empty(map:keys($instance-property)))
                                then map:put($m, $key, json:object())
                                else map:put($m, $key, race:canonicalize($instance-property))
                    (: An array can also treated as multiple elements :)
                        case json:array
                            return
                                (
                                    for $val at $i in json:array-values($instance-property)
                                    return
                                        if ($val instance of json:object)
                                        then json:set-item-at($instance-property, $i, race:canonicalize($val))
                                        else (),
                                    map:put($m, $key, $instance-property)
                                )

                    (: A sequence of values should be simply treated as multiple elements :)
                    (: TODO is this lossy? :)
                        case item()+
                            return
                                for $val in $instance-property
                                return map:put($m, $key, $val)
                        default return map:put($m, $key, $instance-property)
            return $m)
};





(:~
 : Turns an entity instance into an XML structure.
 : This out-of-the box implementation traverses a map structure
 : and turns it deterministically into an XML tree.
 : Using this function as-is should be sufficient for most use
 : cases, and will play well with other generated artifacts.
 : @param $entity-instance A map:map instance returned from one of the extract-instance
 :    functions.
 : @return An XML element that encodes the instance.
 :)
declare private function race:instance-to-canonical-xml(
    $entity-instance as map:map
) as element()
{
(: Construct an element that is named the same as the Entity Type :)
    let $namespace := map:get($entity-instance, "$namespace")
    let $namespace-prefix := map:get($entity-instance, "$namespacePrefix")
    let $nsdecl :=
        if ($namespace) then
            namespace { $namespace-prefix } { $namespace }
        else ()
    let $type-name := map:get($entity-instance, '$type')
    let $type-qname :=
        if ($namespace)
        then fn:QName( $namespace, $namespace-prefix || ":" || $type-name)
        else $type-name
    return
        element { $type-qname }  {
            $nsdecl,
            if ( map:contains($entity-instance, '$ref') )
            then map:get($entity-instance, '$ref')
            else
                for $key in map:keys($entity-instance)
                let $instance-property := map:get($entity-instance, $key)
                let $ns-key :=
                    if ($namespace and $key castable as xs:NCName)
                    then fn:QName( $namespace, $namespace-prefix || ":" || $key)
                    else $key
                where ($key castable as xs:NCName)
                return
                    typeswitch ($instance-property)
                    (: This branch handles embedded objects.  You can choose to prune
                       an entity's representation of extend it with lookups here. :)
                        case json:object+
                            return
                                for $prop in $instance-property
                                return element { $ns-key } { race:instance-to-canonical-xml($prop) }
                    (: An array can also treated as multiple elements :)
                        case json:array
                            return
                                for $val in json:array-values($instance-property)
                                return
                                    if ($val instance of json:object)
                                    then element { $ns-key } {
                                        attribute datatype { 'array' },
                                        race:instance-to-canonical-xml($val)
                                    }
                                    else element { $ns-key } {
                                        attribute datatype { 'array' },
                                        $val }
                    (: A sequence of values should be simply treated as multiple elements :)
                        case item()+
                            return
                                for $val in $instance-property
                                return element { $ns-key } { $val }
                        default return element { $ns-key } { $instance-property }
        }
};


(:
 : Wraps a canonical instance (returned by instance-to-canonical())
 : within an envelope patterned document, along with the source
 : document, which is stored in an attachments section.
 : @param $entity-instance an instance, as returned by an extract-instance
 : function
 : @param $entity-format Either "json" or "xml", selects the output format
 : for the envelope
 : @return A document which wraps both the canonical instance and source docs.
 :)
declare function race:instance-to-envelope(
    $entity-instance as map:map,
    $envelope-format as xs:string
) as document-node()
{
    let $canonical := race:instance-to-canonical($entity-instance, $envelope-format)
    let $attachments := es:serialize-attachments($entity-instance, $envelope-format)
    return
        if ($envelope-format eq "xml")
        then
            document {
                element es:envelope {
                    element es:instance {
                        element es:info {
                            element es:title { map:get($entity-instance,'$type') },
                            element es:version { '0.0.1' }
                        },
                        $canonical
                    },
                    $attachments
                }
            }
        else
            document {
                object-node { 'envelope' :
                object-node { 'instance' :
                object-node { 'info' :
                object-node {
                'title' : map:get($entity-instance,'$type'),
                'version' : '0.0.1'
                }
                }
                    +
                    $canonical
                }
                    +
                    $attachments
                }
            }
};


(:
 : @param $entity-instance an instance, as returned by an extract-instance
 : function
 : @return A document which wraps both the canonical instance and source docs.
 :)
declare function race:instance-to-envelope(
    $entity-instance as map:map
) as document-node()
{
    race:instance-to-envelope($entity-instance, "xml")
};


